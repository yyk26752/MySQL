### 事务

所谓事务就是一个操作序列，要么这些操作都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，当事务结束时，都能保持数据的一致性。比如A转账给B，那么应该将A扣钱，B加钱看做一个事务，要么这些事都执行，要么都不执行。



####事务的四大特性（ACID）

- 原子性(Atomicity)：一个事务被视为一个不可分割的工作单位，事务中的所有操作，要么都执行，要么都不执行，不可能只执行其中一部分操作。
- 一致性(Consistency)：事务执行前后，数据的完整性必须保持一致。即使得数据库从一种正确状态转换成另外一种正确状态。比如银行转账，执行完事务后，最终状态A扣钱，B加钱（事务后正确状态），如果事务执行失败，A不扣钱，B不加钱（事务前正确状态）。
- 隔离性(Isolation)：一个事务所做的修改，在最终提交之前，对其他事务是不可见的，不受其他事务的影响。 隔离是通过用悲观或乐观锁机制实现的。 
- 持久性(Durability)：事务一旦提交，它对数据的修改将永久保存在数据库中。



####事务的并发问题

隔离级别：

- 读未提交( `Read Uncommitted`，RU )：即事务A还未提交，其他事务也可以读到事务A所做的数据修改。最低的隔离级别。
- 读已提交(  `Read Committed` ，RC)：其他事务只能读到事务A提交后所做的数据修改。较高的隔离级别。
- 可重复读( `Repeatable Read`，RR )：事务之间不受影响，一个事务对数据的修改并提交，另一个事务获取不到 。**MySQL默认的隔离级别**。**MySQL8的可重复读不会出现幻读的情况。**
- 可串行化( `Serializable` )：最高的隔离级别。将事务按照顺序来执行，一个事务提交后，另一个事务才能执行，否则另一个事务阻塞。并发性比较低，开发中很少使用。 

**读**

- 脏读：一个事务读到了另一个事务还未提交的数据，即事务A做了修改，还在做其他操作，还未提交，事务B就读到事务A的修改数据。
- 不可重复读：事务A对数据库数据进行修改，在提交前后，使得事务B查询出来的结果不一致。
- 幻读：事务A查询了一些数据，事务B此时插入或者删除了一些数据，事务A再查询时，出现了开始没有的数据。

不可重复读侧重于修改更新数据，幻读侧重于增加，删除数据。

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读   |
| ------------ | ---- | ---------- | ------ |
| 读未提交     | 是   | 是         | 是     |
| 不可重复读   | 否   | 是         | 是     |
| 可重复读     | 否   | 否         | **否** |
| 串行化       | 否   | 否         | 否     |



**写**

- 丢失更新：多个事务在同一时刻对同一行数据进行修改，会导致后面事务提交的更新覆盖前面事务的更新。比如，事务A修改了一条记录，事务B在事务A提交后也进行了一次修改并且提交，事务A再查询时，会发现自己的修改没有生效，好像丢失了更新。

解决丢失更新的方法有两种：

- 悲观锁：总是假设最坏的情况，每次获取数据的时候都认为别人会修改数据，所以每次在获取数据时都会加锁，这样别人想获取该数据就会阻塞，直到他获取锁。（ **共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。比如读锁，写锁等。
- 乐观锁：总是假设最好的情况，每次获取数据都认为别人不会修改，但是在更新时会判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。



**InnoDB行级锁**

数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。对系统的开销大，但处理高并发较好。

- 排它锁(写锁，X锁(eXclusion lock))：如事务A对数据行加上X锁，则只允许A读取和修改它，其他事务都不能再对该数据行加任何形式的锁，直到事务A释放该锁。MySQL客户端(cmd)默认加排它锁。

```sql
-- 手动加X锁
select ... for update;
```

- 共享锁(读锁，S锁(Share lock))：若事务A对数据行加上S锁，则其他事务只能再对该数据行加S锁，而不能加X锁，直到事务A释放S锁，才能加其他锁。

```sql
-- 手动加S锁
select ... lock in share mode;
```



**MVCC**

快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本，一个行记录可能有不止一个快照数据一般称这种技术为行多版本技术。由此带来的并发控制就是多版本并发控制MVCC(Mutil-Version Concurrency Control)。如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据。MVCC极大地提高了数据库的并发性。

MVCC只有在RR和RC两个隔离级别下工作。但是不同的隔离级别，快照数据的定义不同。对于RC隔离级别下，事务读取到的是被锁定行最新的一份快照数据(其他事务对该行修改的也可以读到)。对于RR隔离级别下，读取到的是该事务开始时的行数据版本。

